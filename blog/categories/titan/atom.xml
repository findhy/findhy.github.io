<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Titan | Findhy's Blog]]></title>
  <link href="http://findhy.com/blog/categories/titan/atom.xml" rel="self"/>
  <link href="http://findhy.com/"/>
  <updated>2014-06-20T18:51:24+08:00</updated>
  <id>http://findhy.com/</id>
  <author>
    <name><![CDATA[Findhy]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Titan Tutorial]]></title>
    <link href="http://findhy.com/blog/2014/06/19/titan-tutorial/"/>
    <updated>2014-06-19T13:43:40+08:00</updated>
    <id>http://findhy.com/blog/2014/06/19/titan-tutorial</id>
    <content type="html"><![CDATA[<p>Titan的<a href="https://github.com/thinkaurelius/titan/wiki">官方手册</a>内容更加丰富，但是太多，初学者不知如何下手，本文摘取重点部分，希望能快速上手Titan。</p>

<!--more-->


<h3>1.版本说明</h3>

<pre><code>Titan：titan-server-0.4.4
HBase：hbase-0.94.6-cdh4.3.2
Elasticsearch：elasticsearch-0.90.3
</code></pre>

<h3>2.环境说明</h3>

<p>服务器3台：</p>

<pre><code>master 10.0.1.252
slave1 10.0.1.253
slave2 10.0.1.254
</code></pre>

<p>HBase搭建的是集群，一个master，两个slave；Elasticsearch在master上部署的单机版本；Titan在master上部署的单机版本。本文不包括HBase集群搭建过程。</p>

<h3>3.Elasticsearch安装</h3>

<p>由于Titan0.4.4版本只能支持Elasticsearch的版本是0.90.3，看这里<a href="https://github.com/thinkaurelius/titan/wiki/Version-Compatibility">Version-Compatibility</a>。所以这里注意版本，Elasticsearch 0.90.3的文档可以看这里<a href="http://www.elasticsearch.org/guide/en/elasticsearch/reference/0.90/index.html">Elasticsearch-doc</a>。下面开始安装。</p>

<pre><code>wget https://download.elasticsearch.org/elasticsearch/elasticsearch/elasticsearch-0.90.3.tar.gz
tar –zxvf elasticsearch-0.90.3.tar.gz
cd elasticsearch-0.90.3

启动elasticsearch：
./bin/elasticsearch
执行jps，会看到多了一个ElasticSearch的进程，说明成功
</code></pre>

<h3>4.Titan安装</h3>

<p>Titan有<a href="https://github.com/thinkaurelius/titan/wiki/Downloads">多种版本</a>提供下载，这里选择titan-server-0.4.4。</p>

<pre><code>mkdir /home/hadoop/titan-cdh4.3.2
进入
cd titan-cdh4.3.2
下载
wget http://s3.thinkaurelius.com/downloads/titan/titan-server-0.4.4.zip
解压
unzip titan-server-0.4.4.zip
进入目录
cd titan-server-0.4.4
</code></pre>

<p>修改配置文件</p>

<pre><code>vi ./conf/titan-hbase-es.properties

storage.hostname=master,slave1,slave2
storage.port=2181
cache.db-cache = true
cache.db-cache-clean-wait = 20
cache.db-cache-time = 180000
cache.db-cache-size = 0.5

storage.index.search.backend=elasticsearch
storage.index.search.hostname=master
storage.index.search.client-only=true
</code></pre>

<p>初始化Titan与HBase</p>

<pre><code>cd /home/hadoop/titan-cdh4.3.2/titan-server-0.4.4/
./bin/gremlin.sh

gremlin&gt;g = TitanFactory.open('conf/titan-hbase-es.properties')
</code></pre>

<p>这时候到hbase shell下面执行list命令，可以看到多了一张titan的表，执行describe &lsquo;titan'可以看到titan的表结构，加载数据：</p>

<pre><code>gremlin&gt; GraphOfTheGodsFactory.load(g)
</code></pre>

<p>到hbase shell下面执行scan &lsquo;titan'可以看到初始化了一些数据，下面用gremlin命令行验证一下这些数据</p>

<pre><code>gremlin&gt; saturn = g.V('name','saturn').next()
==&gt;v[4]
gremlin&gt; saturn.map()
==&gt;name=saturn
==&gt;age=10000
==&gt;type=titan
gremlin&gt; saturn.in('father').in('father').name
==&gt;hercules
</code></pre>

<p>如果输出一致则验证成功</p>

<h3>5.Rexster配置</h3>

<p>这部分文档参考：<a href="https://github.com/thinkaurelius/titan/wiki/Rexster-Graph-Server">https://github.com/thinkaurelius/titan/wiki/Rexster-Graph-Server</a></p>

<p>修改rexster配置文件</p>

<pre><code>cd /home/hadoop/titan-cdh4.3.2/titan-server-0.4.4/conf
cp rexster-cassandra-es.xml rexster-hbase-es.xml
vi rexster-hbase-es.xml
</code></pre>

<p>有两个地方要改，一个是http这个标签，一个是graphs这个标签，黄色是需要修改的内容，第一个修改如下：</p>

<pre><code>&lt;http&gt;
  &lt;server-port&gt;8182&lt;/rexster-server-port&gt;
  &lt;base-uri&gt;http://54.255.164.52&lt;/base-uri&gt;
  &lt;web-root&gt;public&lt;/web-root&gt;
  &lt;character-set&gt;UTF-8&lt;/character-set&gt;
  ...
&lt;/http&gt;
</code></pre>

<p>第二个修改如下：</p>

<pre><code>&lt;graphs&gt;
    &lt;graph&gt;
        &lt;graph-name&gt;graph&lt;/graph-name&gt;
       &lt;graph-type&gt;com.thinkaurelius.titan.tinkerpop.rexster.TitanGraphConfiguration&lt;/graph-type&gt;
        &lt;!-- &lt;graph-location&gt;/tmp/titan&lt;/graph-location&gt; --&gt;
        &lt;graph-read-only&gt;false&lt;/graph-read-only&gt;
        &lt;properties&gt;
            &lt;storage.backend&gt;hbase&lt;/storage.backend&gt;
            &lt;storage.hostname&gt;master,slave1,slave2&lt;/storage.hostname&gt;
            &lt;storage.index.search.backend&gt;elasticsearch&lt;/storage.index.search.backend&gt;
            &lt;storage.index.search.hostname&gt;master&lt;/storage.index.search.hostname&gt;
            &lt;!--&lt;storage.index.search.directory&gt;../db/es&lt;/storage.index.search.directory&gt;--&gt;
            &lt;storage.index.search.client-only&gt;false&lt;/storage.index.search.client-only&gt;
            &lt;storage.index.search.local-mode&gt;false&lt;/storage.index.search.local-mode&gt;
        &lt;/properties&gt;
        &lt;extensions&gt;
          &lt;allows&gt;
            &lt;allow&gt;tp:gremlin&lt;/allow&gt;
          &lt;/allows&gt;
        &lt;/extensions&gt;
    &lt;/graph&gt;
&lt;/graphs&gt;
</code></pre>

<p>启动Rexster</p>

<pre><code>cd /home/hadoop/titan-cdh4.3.2/titan-server-0.4.4
./bin/rexster.sh –s –c ../conf/rexster-hbase-es.xml
</code></pre>

<p>访问<a href="http://master-ip:8182/">http://master-ip:8182/</a></p>

<p>出现下面画面则启动成功</p>

<p><img src="/images/titan-tul-1.png"></p>

<p><a href="https://github.com/tinkerpop/rexster/wiki">Rexster</a>是建立在任何实现了Blueprints的图数据库(Graph Database)之上的web server，它提供这三种功能：</p>

<ul>
<li>提供基于REST的接口方法：GET, POST, PUT, and DELETE，去操作Graph Database

<ul>
<li>基于上面的例子，在浏览器输入：<a href="http://master-ip:8182/graphs/graph/edges">http://master-ip:8182/graphs/graph/edges</a>  会返回graph的edge信息</li>
</ul>
</li>
<li><a href="https://github.com/tinkerpop/rexster/wiki/The-Dog-House">The Dog House</a>提供基于浏览器去操作Graph，还有可视化Graph，界面如下：

<ul>
<li><img src="/images/titan-tul-2.png"></li>
<li><img src="/images/titan-tul-3.png"></li>
</ul>
</li>
<li>提供<a href="https://github.com/tinkerpop/rexster/wiki/RexPro-Java">RexsterClient</a>客户端去访问Rexster server，包括执行一些Graph的操作</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Titan经典入门PPT]]></title>
    <link href="http://findhy.com/blog/2014/06/19/titan-classic-get-started/"/>
    <updated>2014-06-19T11:00:50+08:00</updated>
    <id>http://findhy.com/blog/2014/06/19/titan-classic-get-started</id>
    <content type="html"><![CDATA[<p>下面是Marko Rodriguez分享的一个PPT，原文在这里<a href="http://www.slideshare.net/slidarko/titan-the-rise-of-big-graph-data">slideshare.</a>，该PPT深入浅出，从Graph基础知识到Graph Database到Titan的优势，还包括基本的入门操作，我觉得非常经典，很适合初学者，在此分享，因为原文PPT表达很简单而且加上动画展示，所以即使英文不好的人看也没有障碍。</p>

<!--more-->


<p><iframe src="http://www.slideshare.net/slideshow/embed_code/13328271 " width="595" height="446" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC;border-width:1px 1px 0;margin-bottom:5px" allowfullscreen></iframe> </p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[TinkerPop]]></title>
    <link href="http://findhy.com/blog/2014/06/18/tinkerpop/"/>
    <updated>2014-06-18T15:09:59+08:00</updated>
    <id>http://findhy.com/blog/2014/06/18/tinkerpop</id>
    <content type="html"><![CDATA[<p><a href="http://www.tinkerpop.com/">TinkerPop</a>是Graph领域的一系列开源工具包的集合。下面分别介绍：</p>

<!--more-->


<h3>Blueprints</h3>

<p>上一篇文章我们讲<a href="http://findhy.com/blog/2014/06/17/graph-database-data-structure/">Graph Database理论知识</a>的时候，提到了图论关于图(Graph)的定义：顶点和边组成的图形，也在后面提到了关于Graph的一系列操作，包括：插入顶点、插入边、获取路径等等。Blueprints是对图这种抽象模型的具体实现，官方定义：<a href="https://github.com/tinkerpop/blueprints/wiki">Blueprints</a>是一系列<a href="https://github.com/tinkerpop/gremlin/wiki/Defining-a-Property-Graph">属性图模型接口(property graph model interface)</a>，那么接下来，什么是属性图模型(property graph model)？满足下面三个条件的图(Graph)被称为属性图(property graphs)：</p>

<ul>
<li>顶点(vertices)和边(edges)可以包含任意多的key/value的属性</li>
<li>方向性，边(edges)具有方向性，可以从一个顶点(vertices)指向另外一个顶点(vertices)</li>
<li>多样性，顶点(vertices)之间的关系边(edges)可以是不同的类型，就是说两个顶点(vertices)可以拥有多种不同类型的边(edges)</li>
</ul>


<p>满足上述三个条件的graph被称为property graphs，下面展现一个property graphs的例子，数据格式可以是<a href="http://graphml.graphdrawing.org/index.html">GraphML</a>或者<a href="https://github.com/tinkerpop/blueprints/wiki/GraphSON-Reader-and-Writer-Library">GraphSON</a>，前者是<a href="https://github.com/tinkerpop/gremlin/blob/master/data/graph-example-1.xml">XML</a>，后者<a href="https://github.com/tinkerpop/gremlin/blob/master/data/graph-example-1.json">JSON</a>，当然JSON会更轻量级。</p>

<p><img src="/images/tinkpop-1.png"></p>

<p>一个property graphs包含下面这些元素</p>

<ul>
<li>一系列顶点(vertices)

<ul>
<li>每一个顶点(vertex)有一个唯一标识</li>
<li>每一个顶点(vertex)有一个或者多个指向其它顶点的边(edge)</li>
<li>每一个顶点(vertex)有一个或者多个指向自己的边(edge)</li>
<li>每一个顶点(vertex)包含了一个或多个由map定义的key/value属性</li>
</ul>
</li>
<li>一系列边(edges)

<ul>
<li>每一个边(edge)有一个唯一标识</li>
<li>每一个边(edge)具有方向性指向一个顶点(vertex)</li>
<li>每一个边(edge)有一个label来标识两个顶点(vertex)之间的关系</li>
<li>每一个边(edge)包含了一个或多个由map定义的key/value属性</li>
</ul>
</li>
</ul>


<p>什么是property graphs搞明白之后，我们再来看Blueprints，Blueprints为属性图模型(property graph data model)提供了一套接口、实现还有测试用例，你可以把它想象成JDBC，JDBC对数据库的操作原语进行了封装和实现，只不过JDBC是用来操作关系型数据库，而Blueprints用来操作Graph Database。现在主流的Graph Database都支持Blueprints，而且在TinkerPop整个软件栈中，Blueprints是最底层的基础，就是其它的工具包都是基于它之上的封装和扩展。怎么使用Blueprints？</p>

<p>maven引入：</p>

<pre><code>&lt;dependency&gt;
   &lt;groupId&gt;com.tinkerpop.blueprints&lt;/groupId&gt;
   &lt;artifactId&gt;blueprints-core&lt;/artifactId&gt;
   &lt;version&gt;2.5.0&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>

<p>样例代码：</p>

<pre><code>Graph graph = new Neo4jGraph("/tmp/my_graph");
Vertex a = graph.addVertex(null);
Vertex b = graph.addVertex(null);
a.setProperty("name","marko");
b.setProperty("name","peter");
Edge e = graph.addEdge(null, a, b, "knows");
e.setProperty("since", 2006);
graph.shutdown();
</code></pre>

<h3>Pipes</h3>

<p><a href="https://github.com/tinkerpop/pipes/wiki">Pipes</a>是一个图数据处理的框架，可以将它理解为管道(Pipe),它最大的好处是管道(Pipe)的输出可以作为其它管道(Pipe)的输入，这样我们就可以实现类似于mapreducer的复杂运算。</p>

<h3>Gremlin</h3>

<p><a href="https://github.com/tinkerpop/gremlin/wiki">Gremlin</a>是一个图遍历语言，可以用Gremlin来实现图的查询、分析和操作，Gremlin只能适用于支持Blueprints的图数据库，支持多种JVM语言：Java 和 Groovy，文档：<a href="http://gremlindocs.com/">GremlinDocs</a>、<a href="http://sql2gremlin.com/">SQL2Gremlin</a>。</p>

<h3>Frames</h3>

<p><a href="https://github.com/tinkerpop/frames/wiki">Frames</a>是一个object-to-graph映射框架</p>

<h3>Furnace</h3>

<p><a href="https://github.com/tinkerpop/furnace/wiki">Furnace</a>是一个Graph算法包</p>

<h3>Rexster</h3>

<p><a href="https://github.com/tinkerpop/rexster/wiki">Rexster</a>是一个Graph Server</p>

<p>TinkerPop的维护人员来自不同的Graph Database产品厂商，像Neo4j、Titan、OrientDB、Bitsy，它在Graph Database领域的地位我理解就像JavaEE里面的Apache。在最新的<a href="https://github.com/tinkerpop/tinkerpop3">TinkerPop3.0</a>版本的时候，TinkerPop将原本分散的各个工具包合并成了一个项目，并且增加了很多特性，Titan0.5版本还不支持TP3，将会在Titan1.0版本时支持，更多的可以看<a href="http://www.tinkerpop.com/docs/current/">TinkerPop3 Story/doc</a>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Graph Database]]></title>
    <link href="http://findhy.com/blog/2014/06/17/graph-database-data-structure/"/>
    <updated>2014-06-17T14:50:02+08:00</updated>
    <id>http://findhy.com/blog/2014/06/17/graph-database-data-structure</id>
    <content type="html"><![CDATA[<p><a href="http://en.wikipedia.org/wiki/Graph_database">Graph database</a>是近年兴起的NoSQL存储模型(graph, key-value, column, and document)中的一种实现数据库，代表产品是Neo4j、Titan，它的理论基础是<a href="http://zh.wikipedia.org/wiki/%E5%9B%BE%E8%AE%BA">图论/Graph theory</a>,一个数学分支，主要研究顶点和边组成的图形的数学理论和方法，它的起源也比较有意思，这部分本文不谈，感兴趣的同学可以去Google研究一下。</p>

<!--more-->


<p>想了解Graph Database，我们还是要把图论(Graph theory)简单说一下，略过中间复杂的数学问题，我们以结果为导向，图论可以解决哪些问题？这里有一个<a href="http://www.global-sci.org/mc/issues/3/no2/freepdf/67s.pdf">图论经典问题简介</a>,诸如<a href="http://zh.wikipedia.org/wiki/%E6%9C%80%E7%9F%AD%E8%B7%AF%E9%97%AE%E9%A2%98">最短路径问题</a>、<a href="http://zh.wikipedia.org/wiki/%E6%97%85%E8%A1%8C%E6%8E%A8%E9%94%80%E5%91%98%E9%97%AE%E9%A2%98">旅行售货商问题</a>、<a href="http://zh.wikipedia.org/wiki/%E9%82%AE%E9%80%92%E5%91%98%E9%97%AE%E9%A2%98">中国邮递员问题</a>，这些是图论中研究的经典问题，具体实现会涉及到不同的算法问题。</p>

<p>举个例子，在社交网络中，你搜索了一个人，怎么最快结识他，这其实就是一个最短路径问题，LinkedIn已经有相关的推荐产品，可以去试一下。而且未来随着智能设备的普及个人数据会呈现爆炸性增长，就是人的属性和关联会更多更复杂，其实这个问题在阿里现在已经存在了，他收购了那么多产品，重要一点就是为了获取数据，现在阿里拥有一个人的网购数据(淘宝、天猫)、社交数据(陌陌、新浪微博)、浏览搜索数据(UC、优酷)等等，这么庞大的一个数据结构该怎么来描述，更关键的是怎么快速的去做定位和推荐，这也是Graph Database兴起的一个原因，未来Graph这块必然会大放异彩。</p>

<h3>数据结构</h3>

<p>Graph Database的存储单元是：节点(nodes)、关系/边(edges)、属性(properties)<br/>
<img src="/images/GraphDatabase_1.png"></p>

<ul>
<li>节点(nodes)：通常是一个实体，类似于社交网络中的人或者电商网络中的商品，节点不一定都是同一个类型的，比如我们构建一个Graph，节点是人和商品，之间的连接是谁买了哪个商品，这样我们可以很容易找到买相同的产品的人，去做关联推荐</li>
<li>属性(properties)：是与节点(nodes)相关的信息，通常是节点的描述，比如人的性别、年龄、地点、电话等信息</li>
<li>关系/边(edges)：用来连接节点(nodes)的，代表节点(nodes)与节点(nodes)之间具有某种关系，比如用户A和用户B是好友，用户A和用户C来自同一个地方，关系可以是有方向和无方向的，而且节点(nodes)之间可以有多条关系</li>
</ul>


<p>Graph Database的数据结构使得它在处理数据关联问题更具优势，因为它的节点(nodes)原生的就是通过某种关系连接在一起，这样就减少了join这样耗费资源的操作。</p>

<h3>算法</h3>

<p>Graph Database中很多问题都涉及到一些重要算法，下面列举一些，数据来源<a href="http://zh.wikipedia.org/wiki/%E6%9C%80%E7%9F%AD%E8%B7%AF%E9%97%AE%E9%A2%98">Wikipedia-Graph-Algorithms</a>：</p>

<ul>
<li>基本遍历：深度优先搜索、广度优先搜索、A*、Flood fill</li>
<li>最短路径：Dijkstra、Bellman-Ford、Floyd-Warshall 、Kneser图</li>
<li>最小生成树：Prim、Kruskal</li>
<li>强连通分量：Kosaraju算法、Gabow算法、Tarjan算法</li>
<li>图匹配：匈牙利算法、Hopcroft–Karp、Edmonds&rsquo;s matching</li>
<li>网络流：Ford-Fulkerson、Edmonds-Karp、Dinic 、Push-relabel maximum flow</li>
</ul>


<h3>常规操作</h3>

<p>类似于关系型数据库提供的CRUD操作，Graph Database也提供一系列指令来操作Graph，下面G代表一个Graph data structure，你可以把它想象为关系型数据库中的一张表。</p>

<ul>
<li>adjacent(G, x, y)：检查节点x和节点y之间是否有一个边(edge)</li>
<li>neighbors(G, x)：列出所有与节点x有连接/边(edge)的节点</li>
<li>add(G, x, y)：插入一个边(edge)，从x指向y</li>
<li>delete(G, x, y)：删除一个从x指向y的边(edge)</li>
<li>get_node_value(G, x)：返回节点x的相关属性</li>
<li>set_node_value(G, x, a)：设置节点x的属性为a</li>
<li>get_edge_value(G, x, y)：返回节点x和y之间的边(edge)的属性，边(edge)也是有属性的</li>
<li>set_edge_value(G, x, y, v)：设置节点x和y之间的边(edge)的属性为v</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Titan:下一代分布式图数据库]]></title>
    <link href="http://findhy.com/blog/2014/06/17/titan-next-generation-graph-database/"/>
    <updated>2014-06-17T10:23:30+08:00</updated>
    <id>http://findhy.com/blog/2014/06/17/titan-next-generation-graph-database</id>
    <content type="html"><![CDATA[<p><a href="http://thinkaurelius.github.io/titan/">Titan</a>是一个由<a href="http://thinkaurelius.com/">Aurelius</a>维护的开源协议为<a href="http://www.apache.org/licenses/LICENSE-2.0.html">Apache 2.0</a>的分布式图形数据库。</p>

<!--more-->


<p>Graph Database作为NoSQL数据库四种存储模式(graph, key-value, column, and document)的其中一种，近年来发展迅猛，因为随着人工智能和社交网络不断发展和融合，数据结构越来越复杂，举个例子，以用户为中心的模型，用户的相关数据可能来源他的社交网络，也可能来源他的网购记录，也可能来源他的个人可穿戴设备等等，这个数据会呈现爆炸性增长，如果用户基数为千万级，再去做关联和流行度分析会非常复杂，Graph Database处理这样的需求具体天生的优势。目前市面上的<a href="http://en.wikipedia.org/wiki/Graph_database#Graph_database_projects">Graph Database</a>有很多，<a href="http://www.neo4j.org/">Neo4j</a>是最为成熟和知名度最高的产品，但因为Neo4j<a href="http://stackoverflow.com/questions/21558589/neo4j-sharding-aspect/21566766#21566766">不支持分片</a>导致其存在可伸缩性的问题，但是貌似Neo4j已经推出相应的解决方案架构，参考这里<a href="http://info.neotechnology.com/rs/neotechnology/images/Understanding%20Neo4j%20Scalability(2).pdf">Neo4j HA-1</a>、<a href="http://neo4j.com/blog/2013-whats-coming-next-in-neo4j/">Neo4j HA-2</a>。</p>

<p>Titan作为新一代的Graph Database，还比较年轻，但非常有前途，它的优势有几方面：</p>

<ul>
<li>天生支持分布式：横向扩展很容易，并且性能可以线性增长</li>
<li>性能：Titan官方在Titan-0.1-alpha做过一个<a href="http://thinkaurelius.com/2012/08/06/titan-provides-real-time-big-graph-data/">测试</a>，性能表现非常强劲</li>
<li>后端存储无关：它可以将数据存储在不同的数据库，目前支持HBase、Cassandra和BerkeleyDB，而且Titan 0.5.0将会集成另外一个模块：Titan/Hadoop，这样会让Titan与现有的数据平台结合更加容易</li>
<li>后端索引无关：目前支持<a href="http://www.elasticsearch.org/">ElasticSearch</a>和<a href="http://lucene.apache.org/">Apache Lucene</a>两种索引</li>
<li>支持多数据中心的高可用和热备份</li>
<li>原生支持<a href="http://www.tinkerpop.com/">tinkerpop</a>：<a href="http://www.tinkerpop.com/">tinkerpop</a>是一系列Graph领域的开源软件栈</li>
</ul>


<p>Titan的架构图：<br/>
<img src="/images/titan-next-1.png"></p>

<h4>总结</h4>

<p>目前Titan刚刚发布<a href="https://groups.google.com/forum/#!topic/aureliusgraphs/cNb4fKoe95M">Titan 0.5.0-M1</a>版本，增加了很多特性，而且文档更加完善了，Titan 0.5.0 GA会在七月底发布，这会是一个非常接近1.0版本的产品，对于有需求的公司可以进行预研，对它完全掌握了再投入生产，毕竟Titan在实际生产环境的案例和技术文档都比较欠缺。但我相信Titan会成为下一代非常出色的Graph Database，我也会继续研究Titan和发布相关Titan相关的文章，希望能为Titan在中国推广做一些贡献，有感兴趣的同学欢迎一起讨论。</p>
]]></content>
  </entry>
  
</feed>
