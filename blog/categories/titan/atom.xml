<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Titan | Findhy's Blog]]></title>
  <link href="http://findhy.com/blog/categories/titan/atom.xml" rel="self"/>
  <link href="http://findhy.com/"/>
  <updated>2014-06-19T11:40:26+08:00</updated>
  <id>http://findhy.com/</id>
  <author>
    <name><![CDATA[Findhy]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Titan经典入门]]></title>
    <link href="http://findhy.com/blog/2014/06/19/titan-classic-get-started/"/>
    <updated>2014-06-19T11:00:50+08:00</updated>
    <id>http://findhy.com/blog/2014/06/19/titan-classic-get-started</id>
    <content type="html"><![CDATA[<p>下面是Marko Rodriguez分享的一个PPT，原文在这里<a href="http://www.slideshare.net/slidarko/titan-the-rise-of-big-graph-data">slideshare.</a>，该PPT深入浅出，从Graph基础知识到Graph Database到Titan的优势，还包括基本的入门操作，我觉得非常经典，很适合初学者，在此分享，因为原文PPT表达很简单而且加上动画展示，所以即使英文不好的人看也没有障碍。</p>

<!--more-->


<p><iframe src="http://www.slideshare.net/slideshow/embed_code/13328271 " width="595" height="446" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC;border-width:1px 1px 0;margin-bottom:5px" allowfullscreen></iframe> </p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[TinkerPop]]></title>
    <link href="http://findhy.com/blog/2014/06/18/tinkerpop/"/>
    <updated>2014-06-18T15:09:59+08:00</updated>
    <id>http://findhy.com/blog/2014/06/18/tinkerpop</id>
    <content type="html"><![CDATA[<p><a href="http://www.tinkerpop.com/">TinkerPop</a>是Graph领域的一系列开源工具包的集合。下面分别介绍：</p>

<!--more-->


<h3>Blueprints</h3>

<p>上一篇文章我们讲<a href="http://findhy.com/blog/2014/06/17/graph-database-data-structure/">Graph Database理论知识</a>的时候，提到了图论关于图(Graph)的定义：顶点和边组成的图形，也在后面提到了关于Graph的一系列操作，包括：插入顶点、插入边、获取路径等等。Blueprints是对图这种抽象模型的具体实现，官方定义：<a href="https://github.com/tinkerpop/blueprints/wiki">Blueprints</a>是一系列<a href="https://github.com/tinkerpop/gremlin/wiki/Defining-a-Property-Graph">属性图模型接口(property graph model interface)</a>，那么接下来，什么是属性图模型(property graph model)？满足下面三个条件的图(Graph)被称为属性图(property graphs)：</p>

<ul>
<li>顶点(vertices)和边(edges)可以包含任意多的key/value的属性</li>
<li>方向性，边(edges)具有方向性，可以从一个顶点(vertices)指向另外一个顶点(vertices)</li>
<li>多样性，顶点(vertices)之间的关系边(edges)可以是不同的类型，就是说两个顶点(vertices)可以拥有多种不同类型的边(edges)</li>
</ul>


<p>满足上述三个条件的graph被称为property graphs，下面展现一个property graphs的例子，数据格式可以是<a href="http://graphml.graphdrawing.org/index.html">GraphML</a>或者<a href="https://github.com/tinkerpop/blueprints/wiki/GraphSON-Reader-and-Writer-Library">GraphSON</a>，前者是<a href="https://github.com/tinkerpop/gremlin/blob/master/data/graph-example-1.xml">XML</a>，后者<a href="https://github.com/tinkerpop/gremlin/blob/master/data/graph-example-1.json">JSON</a>，当然JSON会更轻量级。</p>

<p><img src="/images/tinkpop-1.png"></p>

<p>一个property graphs包含下面这些元素</p>

<ul>
<li>一系列顶点(vertices)

<ul>
<li>每一个顶点(vertex)有一个唯一标识</li>
<li>每一个顶点(vertex)有一个或者多个指向其它顶点的边(edge)</li>
<li>每一个顶点(vertex)有一个或者多个指向自己的边(edge)</li>
<li>每一个顶点(vertex)包含了一个或多个由map定义的key/value属性</li>
</ul>
</li>
<li>一系列边(edges)

<ul>
<li>每一个边(edge)有一个唯一标识</li>
<li>每一个边(edge)具有方向性指向一个顶点(vertex)</li>
<li>每一个边(edge)有一个label来标识两个顶点(vertex)之间的关系</li>
<li>每一个边(edge)包含了一个或多个由map定义的key/value属性</li>
</ul>
</li>
</ul>


<p>什么是property graphs搞明白之后，我们再来看Blueprints，Blueprints为属性图模型(property graph data model)提供了一套接口、实现还有测试用例，你可以把它想象成JDBC，JDBC对数据库的操作原语进行了封装和实现，只不过JDBC是用来操作关系型数据库，而Blueprints用来操作Graph Database。现在主流的Graph Database都支持Blueprints，而且在TinkerPop整个软件栈中，Blueprints是最底层的基础，就是其它的工具包都是基于它之上的封装和扩展。怎么使用Blueprints？</p>

<p>maven引入：</p>

<pre><code>&lt;dependency&gt;
   &lt;groupId&gt;com.tinkerpop.blueprints&lt;/groupId&gt;
   &lt;artifactId&gt;blueprints-core&lt;/artifactId&gt;
   &lt;version&gt;2.5.0&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>

<p>样例代码：</p>

<pre><code>Graph graph = new Neo4jGraph("/tmp/my_graph");
Vertex a = graph.addVertex(null);
Vertex b = graph.addVertex(null);
a.setProperty("name","marko");
b.setProperty("name","peter");
Edge e = graph.addEdge(null, a, b, "knows");
e.setProperty("since", 2006);
graph.shutdown();
</code></pre>

<h3>Pipes</h3>

<p><a href="https://github.com/tinkerpop/pipes/wiki">Pipes</a>是一个图数据处理的框架，可以将它理解为管道(Pipe),它最大的好处是管道(Pipe)的输出可以作为其它管道(Pipe)的输入，这样我们就可以实现类似于mapreducer的复杂运算。</p>

<h3>Gremlin</h3>

<p><a href="https://github.com/tinkerpop/gremlin/wiki">Gremlin</a>是一个图遍历语言，可以用Gremlin来实现图的查询、分析和操作，Gremlin只能适用于支持Blueprints的图数据库，支持多种JVM语言：Java 和 Groovy，文档：<a href="http://gremlindocs.com/">GremlinDocs</a>、<a href="http://sql2gremlin.com/">SQL2Gremlin</a>。</p>

<h3>Frames</h3>

<p><a href="https://github.com/tinkerpop/frames/wiki">Frames</a>是一个object-to-graph映射框架</p>

<h3>Furnace</h3>

<p><a href="https://github.com/tinkerpop/furnace/wiki">Furnace</a>是一个Graph算法包</p>

<h3>Rexster</h3>

<p><a href="https://github.com/tinkerpop/rexster/wiki">Rexster</a>是一个Graph Server</p>

<p>TinkerPop的维护人员来自不同的Graph Database产品厂商，像Neo4j、Titan、OrientDB、Bitsy，它在Graph Database领域的地位我理解就像JavaEE里面的Apache。在最新的<a href="https://github.com/tinkerpop/tinkerpop3">TinkerPop3.0</a>版本的时候，TinkerPop将原本分散的各个工具包合并成了一个项目，并且增加了很多特性，Titan0.5版本还不支持TP3，将会在Titan1.0版本时支持，更多的可以看<a href="http://www.tinkerpop.com/docs/current/">TinkerPop3 Story/doc</a>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Graph Database]]></title>
    <link href="http://findhy.com/blog/2014/06/17/graph-database-data-structure/"/>
    <updated>2014-06-17T14:50:02+08:00</updated>
    <id>http://findhy.com/blog/2014/06/17/graph-database-data-structure</id>
    <content type="html"><![CDATA[<p><a href="http://en.wikipedia.org/wiki/Graph_database">Graph database</a>是近年兴起的NoSQL存储模型(graph, key-value, column, and document)中的一种实现数据库，代表产品是Neo4j、Titan，它的理论基础是<a href="http://zh.wikipedia.org/wiki/%E5%9B%BE%E8%AE%BA">图论/Graph theory</a>,一个数学分支，主要研究顶点和边组成的图形的数学理论和方法，它的起源也比较有意思，这部分本文不谈，感兴趣的同学可以去Google研究一下。</p>

<!--more-->


<p>想了解Graph Database，我们还是要把图论(Graph theory)简单说一下，略过中间复杂的数学问题，我们以结果为导向，图论可以解决哪些问题？这里有一个<a href="http://www.global-sci.org/mc/issues/3/no2/freepdf/67s.pdf">图论经典问题简介</a>,诸如<a href="http://zh.wikipedia.org/wiki/%E6%9C%80%E7%9F%AD%E8%B7%AF%E9%97%AE%E9%A2%98">最短路径问题</a>、<a href="http://zh.wikipedia.org/wiki/%E6%97%85%E8%A1%8C%E6%8E%A8%E9%94%80%E5%91%98%E9%97%AE%E9%A2%98">旅行售货商问题</a>、<a href="http://zh.wikipedia.org/wiki/%E9%82%AE%E9%80%92%E5%91%98%E9%97%AE%E9%A2%98">中国邮递员问题</a>，这些是图论中研究的经典问题，具体实现会涉及到不同的算法问题。</p>

<p>举个例子，在社交网络中，你搜索了一个人，怎么最快结识他，这其实就是一个最短路径问题，LinkedIn已经有相关的推荐产品，可以去试一下。而且未来随着智能设备的普及个人数据会呈现爆炸性增长，就是人的属性和关联会更多更复杂，其实这个问题在阿里现在已经存在了，他收购了那么多产品，重要一点就是为了获取数据，现在阿里拥有一个人的网购数据(淘宝、天猫)、社交数据(陌陌、新浪微博)、浏览搜索数据(UC、优酷)等等，这么庞大的一个数据结构该怎么来描述，更关键的是怎么快速的去做定位和推荐，这也是Graph Database兴起的一个原因，未来Graph这块必然会大放异彩。</p>

<h3>数据结构</h3>

<p>Graph Database的存储单元是：节点(nodes)、关系/边(edges)、属性(properties)<br/>
<img src="/images/GraphDatabase_1.png"></p>

<ul>
<li>节点(nodes)：通常是一个实体，类似于社交网络中的人或者电商网络中的商品，节点不一定都是同一个类型的，比如我们构建一个Graph，节点是人和商品，之间的连接是谁买了哪个商品，这样我们可以很容易找到买相同的产品的人，去做关联推荐</li>
<li>属性(properties)：是与节点(nodes)相关的信息，通常是节点的描述，比如人的性别、年龄、地点、电话等信息</li>
<li>关系/边(edges)：用来连接节点(nodes)的，代表节点(nodes)与节点(nodes)之间具有某种关系，比如用户A和用户B是好友，用户A和用户C来自同一个地方，关系可以是有方向和无方向的，而且节点(nodes)之间可以有多条关系</li>
</ul>


<p>Graph Database的数据结构使得它在处理数据关联问题更具优势，因为它的节点(nodes)原生的就是通过某种关系连接在一起，这样就减少了join这样耗费资源的操作。</p>

<h3>算法</h3>

<p>Graph Database中很多问题都涉及到一些重要算法，下面列举一些，数据来源<a href="http://zh.wikipedia.org/wiki/%E6%9C%80%E7%9F%AD%E8%B7%AF%E9%97%AE%E9%A2%98">Wikipedia-Graph-Algorithms</a>：</p>

<ul>
<li>基本遍历：深度优先搜索、广度优先搜索、A*、Flood fill</li>
<li>最短路径：Dijkstra、Bellman-Ford、Floyd-Warshall 、Kneser图</li>
<li>最小生成树：Prim、Kruskal</li>
<li>强连通分量：Kosaraju算法、Gabow算法、Tarjan算法</li>
<li>图匹配：匈牙利算法、Hopcroft–Karp、Edmonds&rsquo;s matching</li>
<li>网络流：Ford-Fulkerson、Edmonds-Karp、Dinic 、Push-relabel maximum flow</li>
</ul>


<h3>常规操作</h3>

<p>类似于关系型数据库提供的CRUD操作，Graph Database也提供一系列指令来操作Graph，下面G代表一个Graph data structure，你可以把它想象为关系型数据库中的一张表。</p>

<ul>
<li>adjacent(G, x, y)：检查节点x和节点y之间是否有一个边(edge)</li>
<li>neighbors(G, x)：列出所有与节点x有连接/边(edge)的节点</li>
<li>add(G, x, y)：插入一个边(edge)，从x指向y</li>
<li>delete(G, x, y)：删除一个从x指向y的边(edge)</li>
<li>get_node_value(G, x)：返回节点x的相关属性</li>
<li>set_node_value(G, x, a)：设置节点x的属性为a</li>
<li>get_edge_value(G, x, y)：返回节点x和y之间的边(edge)的属性，边(edge)也是有属性的</li>
<li>set_edge_value(G, x, y, v)：设置节点x和y之间的边(edge)的属性为v</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Titan:下一代分布式图数据库]]></title>
    <link href="http://findhy.com/blog/2014/06/17/titan-next-generation-graph-database/"/>
    <updated>2014-06-17T10:23:30+08:00</updated>
    <id>http://findhy.com/blog/2014/06/17/titan-next-generation-graph-database</id>
    <content type="html"><![CDATA[<p><a href="http://thinkaurelius.github.io/titan/">Titan</a>是一个由<a href="http://thinkaurelius.com/">Aurelius</a>维护的开源协议为<a href="http://www.apache.org/licenses/LICENSE-2.0.html">Apache 2.0</a>的分布式图形数据库。</p>

<!--more-->


<p>Graph Database作为NoSQL数据库四种存储模式(graph, key-value, column, and document)的其中一种，近年来发展迅猛，因为随着人工智能和社交网络不断发展和融合，数据结构越来越复杂，举个例子，以用户为中心的模型，用户的相关数据可能来源他的社交网络，也可能来源他的网购记录，也可能来源他的个人可穿戴设备等等，这个数据会呈现爆炸性增长，如果用户基数为千万级，再去做关联和流行度分析会非常复杂，Graph Database处理这样的需求具体天生的优势。目前市面上的<a href="http://en.wikipedia.org/wiki/Graph_database#Graph_database_projects">Graph Database</a>有很多，<a href="http://www.neo4j.org/">Neo4j</a>是最为成熟和知名度最高的产品，但因为Neo4j<a href="http://stackoverflow.com/questions/21558589/neo4j-sharding-aspect/21566766#21566766">不支持分片</a>导致其存在可伸缩性的问题，但是貌似Neo4j已经推出相应的解决方案架构，参考这里<a href="http://info.neotechnology.com/rs/neotechnology/images/Understanding%20Neo4j%20Scalability(2).pdf">Neo4j HA-1</a>、<a href="http://neo4j.com/blog/2013-whats-coming-next-in-neo4j/">Neo4j HA-2</a>。</p>

<p>Titan作为新一代的Graph Database，还比较年轻，但非常有前途，它的优势有几方面：</p>

<ul>
<li>天生支持分布式：横向扩展很容易，并且性能可以线性增长</li>
<li>性能：Titan官方在Titan-0.1-alpha做过一个<a href="http://thinkaurelius.com/2012/08/06/titan-provides-real-time-big-graph-data/">测试</a>，性能表现非常强劲</li>
<li>后端存储无关：它可以将数据存储在不同的数据库，目前支持HBase、Cassandra和BerkeleyDB，而且Titan 0.5.0将会集成另外一个模块：Titan/Hadoop，这样会让Titan与现有的数据平台结合更加容易</li>
<li>后端索引无关：目前支持<a href="http://www.elasticsearch.org/">ElasticSearch</a>和<a href="http://lucene.apache.org/">Apache Lucene</a>两种索引</li>
<li>支持多数据中心的高可用和热备份</li>
<li>原生支持<a href="http://www.tinkerpop.com/">tinkerpop</a>：<a href="http://www.tinkerpop.com/">tinkerpop</a>是一系列Graph领域的开源软件栈</li>
</ul>


<p>Titan的架构图：<br/>
<img src="/images/titan-next-1.png"></p>

<h4>总结</h4>

<p>目前Titan刚刚发布<a href="https://groups.google.com/forum/#!topic/aureliusgraphs/cNb4fKoe95M">Titan 0.5.0-M1</a>版本，增加了很多特性，而且文档更加完善了，Titan 0.5.0 GA会在七月底发布，这会是一个非常接近1.0版本的产品，对于有需求的公司可以进行预研，对它完全掌握了再投入生产，毕竟Titan在实际生产环境的案例和技术文档都比较欠缺。但我相信Titan会成为下一代非常出色的Graph Database，我也会继续研究Titan和发布相关Titan相关的文章，希望能为Titan在中国推广做一些贡献，有感兴趣的同学欢迎一起讨论。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Titan Introduction]]></title>
    <link href="http://findhy.com/blog/2014/05/14/titan-graph-db/"/>
    <updated>2014-05-14T22:35:18+08:00</updated>
    <id>http://findhy.com/blog/2014/05/14/titan-graph-db</id>
    <content type="html"><![CDATA[<p>Titan是一个高可用的分布式的图数据库，并且可以支撑上千个用户的并发事务，它有下面这些特性：</p>

<!--more-->


<ul>
<li>弹性和性能的线性扩展</li>
<li>容错性</li>
<li>多数据中心的高可用性和热备份</li>
<li>支持事务的ACID和最终一致性</li>
<li>支持多种不同的后端存储<br/>
<em>Apache Cassandra（分布式）<br/>
Apache HBase（分布式）<br/>
Oracle BerkeleyDB（本地的）<br/>
Persistit（本地）</em></li>
<li>支持多种后端索引  <br/>
<em>ElasticSearch<br/>
Apache Lucene</em></li>
<li>与图形处理栈TinkerPop原生集成   <br/>
  <em>图查询语言Gremlin<br/>
  对象到图的映射器Frames<br/>
  图服务器Rexster<br/>
  标准图API：Blueprints</em></li>
<li>Apache2 license 开源协议</li>
</ul>


<p>Titan最大的优势在于其分布式和线性扩展，性能要高于Neo4j。还有支持HBase数据存储，这样可以和整个Hadoop平台完美结合起来，与YARN平台上面其它应用共享数据，但就这一点，以后Tian可能会代替Neo4j成为图数据库的主流。但是Titan目前应用还不是特别广泛，我们也是在尝试，最高版本是0.4，而且有很多需要改进的地方，包括与HBase的配置挺麻烦的，还无法放到YARN上来管理等等。</p>

<p>更多关于Titan的文档可以看<a href="https://github.com/thinkaurelius/titan/wiki">这里</a></p>

<p>可以从<a href="https://github.com/thinkaurelius/titan/wiki/Getting-Started">这里</a>开始</p>
]]></content>
  </entry>
  
</feed>
